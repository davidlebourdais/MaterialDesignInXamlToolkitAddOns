using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.ComponentModel;
using System.Collections.Specialized;
using System.Windows.Data;
using MaterialDesignThemes.Wpf.AddOns.Utils.Commands;
using MaterialDesignThemes.Wpf.AddOns.Utils.DataGrid;

namespace MaterialDesignThemes.Wpf.AddOns
{
    /// <summary>
    /// This control extends conventional DataGrid so it displays features
    /// that helps it match the material design specifications.
    /// </summary>
    public class PagedDataGrid : DataGrid
    {
        #region Private attributes and properties
        private const string _defaultSortMemberPath = "1";   // default invalid but non-null member path for column initialization.
        private bool _itemsSourceInnerChange;                // disables reentrancy when ItemsSource changes
        private bool _canAddRowsInnerChange;                 // disables reentrancy when CanUserAddRows changes
        private bool _sortingInnerChange;                    // disables reentrancy for sorting property changes.
        private bool _checkmarksInnerChange;                 // disables reentrancy when a checkmark value updates.
        private bool _columnsInnerChange;                    // disables columns changed event handling if set.

        private readonly DataTablePagingManager _pagedTable;   // paging manager that will be used to split raw source into pages when required
        private IList<bool> _checkMarksValuesBackup;           // stores a backup of selectors value for control initialization.
        private bool _canUserAddRowCache;                  // stores a backup of the CanUserAddRows property
        private bool _sourceIsReadonly;                      // stores a value indicating if source is readonly

        private List<DataGridColumn> _userDefinedColumns;      // stores a list of columns that are not autogenerated.
        private int _userDefinedColumnOffset;               // offset at which the user defined columns must be positioned in the columns list.

        private int _sortedColumnIndexInit = -1;            // stores the sorted column user-defined initial value.

        /// <summary>
        /// Determines if paging system should be used instead of raw source.
        /// </summary>
        private bool UsesPagingInternal => UsesPaging || ShowsCheckMarks || ShowsIDs || ForceBackgroundLoading || _pagedTable.AreSourceItemsDynamic || _pagedTable.IsSortingPersistent;
        #endregion

        #region Constructors
        /// <summary>
        /// Creates a new instance of <see cref="PagedDataGrid"/>.
        /// </summary>
        public PagedDataGrid()
        {
            // Set default values:
            _userDefinedColumns = new List<DataGridColumn>();

            // Build paging manager to be used:
            _pagedTable = new DataTablePagingManager();
            _pagedTable.TableInformationUpdated += PagedTable_TableInformationUpdated;
            _pagedTable.CurrentPageChanged += PagedTable_CurrentPageChanged;
            _pagedTable.CheckMarkedRowsChanged += PagedTable_CheckMarkedRowsChanged;
            _pagedTable.PageLoading += (_, unused) => IsPageLoading = true;
            _pagedTable.PageLoaded += (_, unused) => IsPageLoading = false;

            // Build inner commands:
            GoToNextPageCommand = new SimpleCommand(() => _pagedTable.GoNext(), () => _pagedTable.HasNext());
            GoToPreviousPageCommand = new SimpleCommand(() => _pagedTable.GoPrevious(), () => _pagedTable.HasPrevious());
            GoToFirstPageCommand = new SimpleCommand(() => _pagedTable.GoFirst(), () => !_pagedTable.CurrentPageIsFirstPage);
            GoToLastPageCommand = new SimpleCommand(() => _pagedTable.GoLast(), () => !_pagedTable.CurrentPageIsLastPage);

            // Hook to base events:
            Columns.CollectionChanged += Columns_CollectionChanged;
            Loaded += PagedDataGrid_Loaded;
        }

        /// <summary>
        /// Occurs when the control is loaded and bindings are resolved.
        /// </summary>
        /// <param name="sender">Unused.</param>
        /// <param name="e">unused.</param>
        private void PagedDataGrid_Loaded(object sender, RoutedEventArgs e)
        {
            Loaded -= PagedDataGrid_Loaded;

            // Reevaluate selected values if set
            // to other than default and control is loaded
            // (i.e. source bindings are resolved):
            _pagedTable.SetRowCheckMarksValues(_checkMarksValuesBackup);
            _checkMarksValuesBackup = null;

            // Reevaluate sorting as source might have been null
            // when sorting properties were evaluated:
            if (SortedColumnIndex != _sortedColumnIndexInit)
                SortedColumnIndex = _sortedColumnIndexInit;
        }

        /// <summary>
        /// Static constructor for <see cref="PagedDataGrid"/> type.
        /// Override some base dependency properties.
        /// </summary>
        static PagedDataGrid()
        {
            DefaultStyleKeyProperty.OverrideMetadata(typeof(PagedDataGrid), new FrameworkPropertyMetadata(typeof(PagedDataGrid)));
            ItemsSourceProperty.OverrideMetadata(typeof(PagedDataGrid), new FrameworkPropertyMetadata(null, ItemsSourcePropertyChanged));
            CanUserAddRowsProperty.OverrideMetadata(typeof(PagedDataGrid), new FrameworkPropertyMetadata(false, CanUserAddRowsPropertyChanged));
        }
        #endregion

        #region Core properties and methods
        /// <summary>
        /// Called whenever the <see cref="ItemsControl.ItemsSource"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void ItemsSourcePropertyChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted))
                return;
            
            var newSource = args.NewValue as IEnumerable<object>;
            
            if (args.NewValue != null && newSource == null)
                return;

            if (casted._itemsSourceInnerChange)
                return;
            
            casted._pagedTable.SetSource(newSource);
            casted.ProcessCanUserAddRowsForNewSource(newSource);
        }

        /// <summary>
        /// Occurs whenever table information changes.
        /// Allows to internally update every related properties.
        /// </summary>
        /// <param name="sender">Unused.</param>
        /// <param name="e">Unused.</param>
        /// <remarks>Core method, syncs with page manager.</remarks>
        private void PagedTable_TableInformationUpdated(object sender, EventArgs e)
        {
            // Update properties:
            (GoToNextPageCommand as SimpleCommand)?.RaiseCanExecuteChanged();
            (GoToPreviousPageCommand as SimpleCommand)?.RaiseCanExecuteChanged();

            CurrentPageIndex = _pagedTable.CurrentPageIndex;
            CheckMarksColumnIndex = _pagedTable.CheckMarksColumnPosition;
            IdsColumnIndex = _pagedTable.IndexesColumnPosition;
            DisplayedIDs = new ReadOnlyCollection<int>(_pagedTable.DisplayedIndexes);

            ProcessCanUserAddRows();
            UpdateCurrentVisibleItemRangeText();

            // Reset sorting if disabled in paged table (except if currently set as ascending 
            // on the ID column, which is the default 'unsorted' case):
            if (IsLoaded && !_pagedTable.IsSorting && SortedColumnIndex >= 0
                && (!ShowsIDs || SortedColumnIndex != IdsColumnIndex || IsSortingDescending))
                SortedColumnIndex = -1;
            else if (_pagedTable.IsSorting && _pagedTable.SortingColumnIndex != SortedColumnIndex)
            {
                _sortingInnerChange = true;
                SortedColumnIndex = _pagedTable.SortingColumnIndex;
                _sortingInnerChange = false;
            }
        }

        /// <summary>
        /// Occurs whenever paged table page changes.
        /// Allows to internally update every related properties.
        /// </summary>
        /// <param name="sender">Unused.</param>
        /// <param name="e">Unused.</param>
        /// <remarks>Core method, syncs with page manager.</remarks>
        private void PagedTable_CurrentPageChanged(object sender, EventArgs e)
        {
            // Update DataGrid source items if required:
            if (!UsesPagingInternal)
                return;
            
            _itemsSourceInnerChange = true;
            CancelEditWithCare();
            _columnsInnerChange = true;
            SetCurrentValue(ItemsSourceProperty, _pagedTable.CurrentPage.DefaultView);
            _columnsInnerChange = false;
            _itemsSourceInnerChange = false;
        }

        /// <summary>
        /// Called whenever the checkmark selection list changes.
        /// </summary>
        /// <param name="sender">Unused.</param>
        /// <param name="e">Unused.</param>
        private void PagedTable_CheckMarkedRowsChanged(object sender, EventArgs e)
        {
            // Update checkmarks:
            CheckMarkedItems = _pagedTable.CheckMarkedRows;
            SelectAllRowsIsTriStated = _pagedTable.AllRowsCheckMarkState == null;
            SelectAllRowsState = _pagedTable.AllRowsCheckMarkState;
            if (_checkMarksValuesBackup != null) // update only if there is no backup ready to be injected when control loads.
                return;
            
            _checkmarksInnerChange = true;
            CheckMarksValues = _pagedTable.CheckMarks.Select(x => x.IsChecked).ToList();
            _checkmarksInnerChange = false;
        }

        /// <summary>
        /// Called at DataGrid column generation.
        /// </summary>
        /// <param name="e">Event info.</param>
        protected override void OnAutoGeneratingColumn(DataGridAutoGeneratingColumnEventArgs e)
        {
            // Clears column at first call if not already prepared:
            if (!_columnsInnerChange)
            {
                _columnsInnerChange = true;  // lock user defined column registration.
                Columns.Clear();
            }

            // Reevaluate user defined offset if there is user defined columns:
            if (!Columns.Any() && _userDefinedColumns.Any())
                EvaluateUserDefinedColumnOffset();

            // Determines if is a special column:
            var index = Columns.Count;
            var isSelect = ShowsCheckMarks && index == CheckMarksColumnIndex;
            var isId = ShowsIDs && index == IdsColumnIndex;
            var isSorted = index == SortedColumnIndex;

            if(_userDefinedColumns.Any() && index == _userDefinedColumnOffset)
                _userDefinedColumns.ForEach(x =>
                {
                    x.CanUserSort &= !UsesPagingInternal;  // user defined columns sorting not supported in paging system for now.
                    if (!Columns.Contains(x))
                        Columns.Add(x);
                });

            // Determine if a TextBox Column was generated as default type while underlying type is not string
            // as GenerateColumns() from base DataGrid uses this type as default value when not finding a supported
            // type. In this case then, process as if it was a DataGridTemplateColumn instead.
            var asTemplateColumn = false;
            if (!isSelect && !isId && e.Column is DataGridTextColumn boundColumn && 
                boundColumn.Binding is Binding binding && binding.Path != null) // Get current binding path that point to property/i.e. column name.
            // Be actually kind and do not override if no cell template is provided:
            {
                
                var propertyInfo = ((IItemProperties)Items).ItemProperties;
                if (propertyInfo.Count > 0)
                {
                    var matching = propertyInfo.FirstOrDefault(x => x.Name == binding.Path.Path);
                    if (matching != null && matching.PropertyType != typeof(string))
                    {
                        // Be actually kind and do not override template if no cell template is provided:
                        if (CellTemplate != null || CellTemplateSelector != null)
                            asTemplateColumn = true;
                        // But propagate sortable setting if using paging, as base disables sorting for non-IComparable types
                        // while the paging system offers the ToString() alternative:
                        if (UsesPagingInternal && !matching.PropertyType.GetInterfaces().Contains(typeof(IComparable)))
                            e.Column.CanUserSort = CanUserSortColumns;
                    }
                }
            }

            // Cancel only when necessary, i.e. when a checkmark, id, or template column:
            if (isSelect || isId || (e.Column is DataGridTemplateColumn) || asTemplateColumn)
            {               
                e.Column = new PagedDataGridTemplateColumn(isId, isSelect)
                {
                    Header = e.Column.Header,
                    HeaderStringFormat = e.Column.HeaderStringFormat,
                    SortMemberPath = string.IsNullOrEmpty(CommonSortedMemberPath) ? _defaultSortMemberPath : CommonSortedMemberPath,
                    HeaderStyle =
                        isSelect ? CheckMarksColumnHeaderStyle :
                        isId ? IdsColumnHeaderStyle :
                        e.Column.HeaderStyle ?? ColumnHeaderStyle,
                    HeaderTemplate =
                        isSelect ? CheckMarksColumnHeaderTemplate :
                        isId ? IdsColumnHeaderTemplate :
                        e.Column.HeaderTemplate ?? ColumnHeaderTemplate,
                    HeaderTemplateSelector =
                        isSelect ? CheckMarksColumnHeaderTemplateSelector :
                        isId ? IdsColumnHeaderTemplateSelector :
                        e.Column.HeaderTemplateSelector ?? ColumnHeaderTemplateSelector,
                    CellStyle =
                        isSelect ? CheckMarkCellStyle :
                        isId ? IdCellStyle :
                        e.Column.CellStyle ?? CellStyle,
                    CellTemplate =
                        isSelect ? CheckMarkCellTemplate :
                        isId ? IdCellTemplate :
                        (e.Column as DataGridTemplateColumn)?.CellTemplate ?? CellTemplate,
                    CellTemplateSelector =
                        isSelect ? CheckMarkCellTemplateSelector :
                        isId ? IdCellTemplateSelector :
                        (e.Column as DataGridTemplateColumn)?.CellTemplateSelector ?? CellTemplateSelector,
                    CellEditingTemplate =
                        isSelect ? CheckMarkCellEditingTemplate :
                        (e.Column as DataGridTemplateColumn)?.CellEditingTemplate ?? CellEditingTemplate,
                    CellEditingTemplateSelector =
                        isSelect ? CheckMarkCellEditingTemplateSelector :
                        (e.Column as DataGridTemplateColumn)?.CellEditingTemplateSelector ?? CellEditingTemplateSelector,
                    IsReadOnly = isId,
                    CanUserSort = e.Column.CanUserSort && CanUserSortColumns,
                    CanUserResize = e.Column.CanUserResize && CanUserResizeColumns,
                    CanUserReorder = CanUserReorderIDsAndCheckMarksColumns || (!isId && !isSelect && e.Column.CanUserReorder && CanUserReorderColumns),
                    SortDirection = !isSorted ? (ListSortDirection?)null : (IsSortingDescending ? ListSortDirection.Descending : ListSortDirection.Ascending),
                    Width = e.Column.Width,
                    MinWidth = e.Column.MinWidth,
                    MaxWidth = e.Column.MaxWidth,
                    ClipboardContentBinding = e.Column.ClipboardContentBinding,
                    DragIndicatorStyle = e.Column.DragIndicatorStyle,      
                    Visibility = e.Column.Visibility
                };
            }
            else // just correct some properties and perform sorting before we let base do the job:
            {
                if (e.Column.HeaderStyle == null)
                    e.Column.HeaderStyle = ColumnHeaderStyle;
                if (e.Column.HeaderTemplate == null)
                    e.Column.HeaderTemplate = ColumnHeaderTemplate;
                if (e.Column.HeaderTemplateSelector == null)
                    e.Column.HeaderTemplateSelector = ColumnHeaderTemplateSelector;
                if (e.Column.CellStyle == null)
                    e.Column.CellStyle = CellStyle;

                if (isSorted)  // just update sorting arrow if needed:
                    e.Column.SortDirection = IsSortingDescending ? ListSortDirection.Descending : ListSortDirection.Ascending;
            }

            base.OnAutoGeneratingColumn(e);
        }

        /// <summary>
        /// Occurs whenever columns auto-generation is over.
        /// </summary>
        /// <param name="e">Event information.</param>
        protected override void OnAutoGeneratedColumns(EventArgs e)
        {
            _columnsInnerChange = false;  // unlock user defined column registration.  
            base.OnAutoGeneratedColumns(e);
        }

        /// <summary>
        /// Evaluates where the user defined columns should be positioned 
        /// regarding to checkmark and ID columns existence and positioning.
        /// </summary>
        private void EvaluateUserDefinedColumnOffset()
        {
            _userDefinedColumnOffset = 0;
            if (ShowsCheckMarks && !ShowsIDs && CheckMarksColumnIndex == 0)
                _userDefinedColumnOffset = 1;
            else if (ShowsIDs && !ShowsCheckMarks && IdsColumnIndex == 0)
                _userDefinedColumnOffset = 1;
            else if (ShowsCheckMarks && ShowsIDs)
            {
                if (CheckMarksColumnIndex < 2 && IdsColumnIndex < 2)
                    _userDefinedColumnOffset = 2;
                else if (CheckMarksColumnIndex == 0 || IdsColumnIndex == 0)
                    _userDefinedColumnOffset = 1;
            }
        }

        /// <summary>
        /// Occurs whenever the column collection changes.
        /// </summary>
        /// <param name="sender">The collection that changed.</param>
        /// <param name="e">Collection changed event information.</param>
        private void Columns_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            // Sync user defined columns based on changes that won't be disables through columns_inner_change
            // (i.e. we know this is not due to autogenerated columns)
            // + keeps select and id columns first if needed.
            if (_columnsInnerChange || sender != Columns)
                return;
            
            if (_userDefinedColumns == null)
                _userDefinedColumns = new List<DataGridColumn>(Columns.Where(x => !x.IsAutoGenerated));
            else
            {
                // Prepare base data:
                EvaluateUserDefinedColumnOffset();
                var indexOffset = _userDefinedColumnOffset;
                var i = 0;
                var userDefinedColumnCount = _userDefinedColumns.Count;

                // Process regarding to collection changed type:
                switch (e.Action)
                {
                    case NotifyCollectionChangedAction.Add:
                        foreach (DataGridColumn item in e.NewItems)
                        {
                            if (e.NewStartingIndex + i < userDefinedColumnCount)
                                _userDefinedColumns.Insert(e.NewStartingIndex + i, item);
                            else _userDefinedColumns.Add(item);
                            i++;
                        }
                        break;

                    case NotifyCollectionChangedAction.Remove:
                        for (i = e.OldStartingIndex; i < e.OldStartingIndex + e.OldItems.Count; i++)
                            if (i < _userDefinedColumns.Count)
                                _userDefinedColumns.RemoveAt(i);
                        break;

                    case NotifyCollectionChangedAction.Replace:
                        for (i = 0; i < e.OldItems.Count; i++)
                        {
                            var index = i + e.OldStartingIndex;
                            if (index >= userDefinedColumnCount)
                                continue;
                            
                            var newItem = i < e.NewItems.Count ? e.NewItems[i] as DataGridColumn : null;
                            if (newItem == null)
                                continue;
                            
                            _userDefinedColumns.RemoveAt(index);
                            
                            if (index < userDefinedColumnCount - 1)
                                _userDefinedColumns.Insert(index, newItem);
                            else _userDefinedColumns.Add(newItem);
                        }
                        break;

                    case NotifyCollectionChangedAction.Move:
                        for (i = 0; i < e.OldItems.Count; i++)
                        {
                            var oldIndex = i + e.OldStartingIndex;
                            var newIndex = i + e.NewStartingIndex;
                            if (oldIndex >= userDefinedColumnCount || newIndex >= userDefinedColumnCount)
                                continue;
                            
                            var movingItem = _userDefinedColumns[oldIndex];
                            _userDefinedColumns.RemoveAt(oldIndex);
                            if (newIndex < userDefinedColumnCount - 1)
                                _userDefinedColumns.Insert(newIndex, movingItem);
                            else _userDefinedColumns.Add(movingItem);
                        }
                        break;

                    case NotifyCollectionChangedAction.Reset:
                        _userDefinedColumns.Clear();
                        break;
                }

                if (indexOffset > 0 && UsesPagingInternal)
                {
                    // Call later to properly update columns outside this function context (as we cannot 
                    // modify it in its own collection changed event handler:
                    Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority.Render, new Action(() =>
                    {
                        _pagedTable.UpdateCurrentPage();
                    }));
                }
            }
        }
        #endregion

        #region CanUserAddRows property override
        /// <summary>
        /// Called whenever the <see cref="DataGrid.CanUserAddRows"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void CanUserAddRowsPropertyChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted))
                return;
            
            if (!casted._canAddRowsInnerChange)  // store backup when user change value.
                casted._canUserAddRowCache = args.NewValue as bool? == true;
        }

        /// <summary>
        /// Determines the <see cref="DataGrid.CanUserAddRows"/> property depending
        /// on the source type (if writeable or not).
        /// </summary>
        /// <param name="newSource">A reference to the newly set source.</param>
        private void ProcessCanUserAddRowsForNewSource(IEnumerable<object> newSource = null)
        {
            // If has a new source in writable mode:
            if (newSource is IList list && !list.IsReadOnly)
                _sourceIsReadonly = false;
            // If has new source that is not writeable:
            else
                _sourceIsReadonly = true;

            ProcessCanUserAddRows();
        }

        /// <summary>
        /// Determines the <see cref="DataGrid.CanUserAddRows"/> property depending
        /// on various internal factor related to paging and source typ.
        /// </summary>
        private void ProcessCanUserAddRows()
        {
            switch (CanUserAddRows)
            {
                // Can add items only if at last page:
                case false when _canUserAddRowCache && !_sourceIsReadonly && _pagedTable.CurrentPageIsLastPage && _pagedTable.SourceItemsCount > 0:
                    CanUserAddRows = true;
                    break;
                case true when (!_pagedTable.CurrentPageIsLastPage || _sourceIsReadonly || _pagedTable.SourceItemsCount == 0):
                    _canAddRowsInnerChange = true;
                    CanUserAddRows = false;
                    _canAddRowsInnerChange = false;
                    break;
            }
        }
        #endregion

        #region Commands related to page navigation
        /// <summary>
        /// Gets the command to reach next page.
        /// </summary>
        public ICommand GoToNextPageCommand { get; }

        /// <summary>
        /// Gets the command to reach previous page.
        /// </summary>
        public ICommand GoToPreviousPageCommand { get; }

        /// <summary>
        /// Gets the command to reach first page.
        /// </summary>
        public ICommand GoToFirstPageCommand { get; }

        /// <summary>
        /// Gets the command to reach last page.
        /// </summary>
        public ICommand GoToLastPageCommand { get; }
        #endregion

        #region MemberPaths
        /// <summary>
        /// Gets or sets the corner radius to be applied to the control.
        /// </summary>
        public Type IntermediatePropertyValueType
        {
            get => (Type)GetValue(IntermediatePropertyValueTypeProperty);
            set => SetCurrentValue(IntermediatePropertyValueTypeProperty, value);
        }
        /// <summary>
        /// Registers <see cref="IntermediatePropertyValueType"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty IntermediatePropertyValueTypeProperty
            = DependencyProperty.Register(nameof(IntermediatePropertyValueType), typeof(Type), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(Type), IntermediatePropertyValueTypeChanged));

        /// <summary>
        /// Called whenever the <see cref="IntermediatePropertyValueType"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void IntermediatePropertyValueTypeChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted))
                return;
            
            casted.CancelEditWithCare();
            casted._pagedTable.IntermediatePropertyValueType = args.NewValue as Type;
            casted._pagedTable.UpdateCurrentPage();
        }
        #endregion

        #region General properties
        /// <summary>
        /// Gets or sets the corner radius to be applied to the control.
        /// </summary>
        public CornerRadius CornerRadius
        {
            get => (CornerRadius)GetValue(CornerRadiusProperty);
            set => SetCurrentValue(CornerRadiusProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CornerRadius"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CornerRadiusProperty
            = DependencyProperty.Register(nameof(CornerRadius), typeof(CornerRadius), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(CornerRadius)));

        /// <summary>
        /// Gets or sets a value indicating if column headers must be shown.
        /// </summary>
        /// <remarks>Will partly (on column header visibility) override the <see cref="DataGrid.HeadersVisibility"/> property.</remarks>
        public bool ShowsHeaders
        {
            get => (bool)GetValue(ShowsHeadersProperty);
            set => SetCurrentValue(ShowsHeadersProperty, value);
        }
        /// <summary>
        /// Registers <see cref="ShowsHeadersProperty"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty ShowsHeadersProperty
            = DependencyProperty.Register(nameof(ShowsHeaders), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(true, ShowsHeadersChanged));

        /// <summary>
        /// Called whenever the <see cref="ShowsHeaders"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void ShowsHeadersChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted) || !(args.NewValue is bool newValue))
                return;
            
            if (newValue)
            {
                if (casted.HeadersVisibility == DataGridHeadersVisibility.Row)
                    casted.HeadersVisibility = DataGridHeadersVisibility.All;
                else if (casted.HeadersVisibility == DataGridHeadersVisibility.None)
                    casted.HeadersVisibility = DataGridHeadersVisibility.Column;
            }
            else
            {
                if (casted.HeadersVisibility == DataGridHeadersVisibility.Column)
                    casted.HeadersVisibility = DataGridHeadersVisibility.None;
                else if (casted.HeadersVisibility == DataGridHeadersVisibility.All)
                    casted.HeadersVisibility = DataGridHeadersVisibility.Row;
            }
        }     

        /// <summary>
        /// Gets or sets a value indicating if paging is activated.
        /// </summary>
        public bool UsesPaging
        {
            get => (bool)GetValue(UsesPagingProperty);
            set => SetCurrentValue(UsesPagingProperty, value);
        }
        /// <summary>
        /// Registers <see cref="UsesPagingProperty"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty UsesPagingProperty
            = DependencyProperty.Register(nameof(UsesPaging), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(true, UsesPagingChanged));

        /// <summary>
        /// Called whenever the <see cref="UsesPaging"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void UsesPagingChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted) || !(args.NewValue is bool newValue))
                return;
            
            casted.CancelEditWithCare();

            if (!newValue)
            {
                casted._pagedTable.PagingEnabled = false;
                casted.PagingOptionsVisibility = Visibility.Collapsed;
            }
            else
            {
                casted._pagedTable.PagingEnabled = true;
                casted.PagingOptionsVisibility = Visibility.Visible;
            }

            try
            {
                casted._columnsInnerChange = true;
                casted.InvalidateProperty(ItemsSourceProperty);  // will force property to reevaluate and tie to source without going through pages.
            }
            finally
            {
                casted._columnsInnerChange = false;
            }
        }

        /// <summary>
        /// Gets the visibility of the paging options.
        /// </summary>
        public Visibility PagingOptionsVisibility
        {
            get => (Visibility)GetValue(PagingOptionsVisibilityProperty);
            protected set => SetValue(_pagingOptionsVisibilityPropertyKey, value);
        }
        private static readonly DependencyPropertyKey _pagingOptionsVisibilityPropertyKey =
            DependencyProperty.RegisterReadOnly(nameof(PagingOptionsVisibility), typeof(Visibility), typeof(PagedDataGrid), new PropertyMetadata(Visibility.Visible));
        /// <summary>
        /// Registers <see cref="PagingOptionsVisibility"/> as a readonly dependency property.
        /// </summary>
        public static readonly DependencyProperty PagingOptionsVisibilityProperty = _pagingOptionsVisibilityPropertyKey.DependencyProperty;

        /// <summary>
        /// Gets or sets the template to be used for paging options control, including navigation arrows.
        /// </summary>
        public DataTemplate PagingOptionsTemplate
        {
            get => (DataTemplate)GetValue(PagingOptionsTemplateProperty);
            set => SetCurrentValue(PagingOptionsTemplateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="PagingOptionsTemplate"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty PagingOptionsTemplateProperty
            = DependencyProperty.Register(nameof(PagingOptionsTemplate), typeof(DataTemplate), typeof(PagedDataGrid), new FrameworkPropertyMetadata(null));

        /// <summary>
        /// Gets or sets a value indicating if controls allowing to go to first or last page should be shown.
        /// </summary>
        /// <remarks>No special behavior on this property, just an helper for templating.</remarks>
        public bool ShowsGoToFirstAndLastPageControls
        {
            get => (bool)GetValue(ShowsGoToFirstAndLastPageControlsProperty);
            set => SetCurrentValue(ShowsGoToFirstAndLastPageControlsProperty, value);
        }
        /// <summary>
        /// Registers <see cref="ShowsGoToFirstAndLastPageControls"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty ShowsGoToFirstAndLastPageControlsProperty
            = DependencyProperty.Register(nameof(ShowsGoToFirstAndLastPageControls), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(bool)));

        /// <summary>
        /// Gets or sets from how many rows found in the source background loading must be used.
        /// </summary>
        public int BackgroundLoadingThreshold
        {
            get => (int)GetValue(BackgroundLoadingThresholdProperty);
            set => SetCurrentValue(BackgroundLoadingThresholdProperty, value);
        }
        /// <summary>
        /// Registers <see cref="BackgroundLoadingThreshold"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty BackgroundLoadingThresholdProperty
            = DependencyProperty.Register(nameof(BackgroundLoadingThreshold), typeof(int), typeof(PagedDataGrid), new FrameworkPropertyMetadata(DataTablePagingManager.DefaultThresholdBgLoadSize, BackgroundLoadingThresholdChanged));

        /// <summary>
        /// Called whenever the <see cref="BackgroundLoadingThreshold"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void BackgroundLoadingThresholdChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (sender is PagedDataGrid casted && args.NewValue is int newValue)
                casted._pagedTable.SetLoadSizeThreshold(newValue);
        }

        /// <summary>
        /// Gets or sets how many rows should be loaded per background thread turn.
        /// </summary>
        public int BackgroundLoadSize
        {
            get => (int)GetValue(BackgroundLoadSizeProperty);
            set => SetCurrentValue(BackgroundLoadSizeProperty, value);
        }
        /// <summary>
        /// Registers <see cref="BackgroundLoadSize"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty BackgroundLoadSizeProperty
            = DependencyProperty.Register(nameof(BackgroundLoadSize), typeof(int), typeof(PagedDataGrid), new FrameworkPropertyMetadata(DataTablePagingManager.DefaultItemBgLoadSize, BackgroundLoadSizeChanged));

        /// <summary>
        /// Called whenever the <see cref="BackgroundLoadSize"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void BackgroundLoadSizeChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (sender is PagedDataGrid casted && args.NewValue is int newValue)
                casted._pagedTable.SetLoadSize(newValue);
        }

        /// <summary>
        /// Gets or sets a value that indicates if background loading shall be used even when 
        /// not using paging, selection or ID features.
        /// </summary>
        public bool ForceBackgroundLoading
        {
            get => (bool)GetValue(ForceBackgroundLoadingProperty);
            set => SetCurrentValue(ForceBackgroundLoadingProperty, value);
        }
        /// <summary>
        /// Registers <see cref="ForceBackgroundLoading"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty ForceBackgroundLoadingProperty
            = DependencyProperty.Register(nameof(ForceBackgroundLoading), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(bool), ForceBackgroundLoadingChanged));

        /// <summary>
        /// Called whenever the <see cref="ForceBackgroundLoading"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void ForceBackgroundLoadingChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted) || !(args.NewValue is bool newValue))
                return;
            
            // In case setting this property enabled paging 
            // then force page to update:
            if (newValue && !casted.UsesPaging && !casted.ShowsCheckMarks && !casted.ShowsIDs && !casted._pagedTable.AreSourceItemsDynamic)
            {
                casted.CancelEditWithCare();
                casted._pagedTable.UpdateCurrentPage();
            }
            // In case unsetting this property disabled paging,
            // then force source update to original list:
            else if (!newValue && !casted.UsesPagingInternal)
            {
                casted.CancelEditWithCare();

                try
                {
                    casted._columnsInnerChange = true;
                    casted.InvalidateProperty(ItemsSourceProperty);
                }
                finally
                {
                    casted._columnsInnerChange = false;
                }
            }
        }

        /// <summary>
        /// Gets a value indicating if page is loading in the background.
        /// </summary>
        public bool IsPageLoading
        {
            get => (bool)GetValue(IsPageLoadingProperty);
            protected set => SetValue(_isPageLoadingPropertyKey, value);
        }
        private static readonly DependencyPropertyKey _isPageLoadingPropertyKey =
            DependencyProperty.RegisterReadOnly(nameof(IsPageLoading), typeof(bool), typeof(PagedDataGrid), new PropertyMetadata(default(bool)));
        /// <summary>
        /// Registers <see cref="IsPageLoading"/> as a readonly dependency property.
        /// </summary>
        public static readonly DependencyProperty IsPageLoadingProperty = _isPageLoadingPropertyKey.DependencyProperty;

        /// <summary>
        /// Gets or sets the text to be displayed when items are loading in the background.
        /// </summary>
        public string PageLoadingText
        {
            get => (string)GetValue(PageLoadingTextProperty);
            set => SetCurrentValue(PageLoadingTextProperty, value);
        }
        /// <summary>
        /// Registers <see cref="PageLoadingText"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty PageLoadingTextProperty
            = DependencyProperty.Register(nameof(PageLoadingText), typeof(string), typeof(PagedDataGrid), new FrameworkPropertyMetadata("Background loading in progress"));
        #endregion

        #region Rows per page
        /// <summary>
        /// Gets or sets a value indicating if the rows per page property can be edited.
        /// </summary>
        public bool CanChangeRowsPerPage
        {
            get => (bool)GetValue(CanChangeRowsPerPageProperty);
            set => SetCurrentValue(CanChangeRowsPerPageProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CanChangeRowsPerPage"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CanChangeRowsPerPageProperty
            = DependencyProperty.Register(nameof(CanChangeRowsPerPage), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(true, CanChangeRowsPerPageChanged));

        /// <summary>
        /// Called whenever the <see cref="CanChangeRowsPerPage"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void CanChangeRowsPerPageChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (sender is PagedDataGrid casted && args.NewValue is bool)
                casted.RowsPerPageSelectionVisibility = args.NewValue as bool? == true ? Visibility.Visible : Visibility.Collapsed;
        }

        /// <summary>
        /// Gets the rows per page selection option visibility.
        /// </summary>
        public Visibility RowsPerPageSelectionVisibility
        {
            get => (Visibility)GetValue(RowsPerPageSelectionVisibilityProperty);
            protected set => SetValue(_rowsPerPageSelectionVisibilityPropertyKey, value);
        }
        private static readonly DependencyPropertyKey _rowsPerPageSelectionVisibilityPropertyKey =
            DependencyProperty.RegisterReadOnly(nameof(RowsPerPageSelectionVisibility), typeof(Visibility), typeof(PagedDataGrid), new PropertyMetadata(Visibility.Visible));
        /// <summary>
        /// Registers <see cref="RowsPerPageSelectionVisibility"/> as a readonly dependency property.
        /// </summary>
        public static readonly DependencyProperty RowsPerPageSelectionVisibilityProperty = _rowsPerPageSelectionVisibilityPropertyKey.DependencyProperty;

        /// <summary>
        /// Gets or sets the template to be used for rows per page selection.
        /// </summary>
        public DataTemplate RowsPerPageSelectionTemplate
        {
            get => (DataTemplate)GetValue(RowsPerPageSelectionTemplateProperty);
            set => SetCurrentValue(RowsPerPageSelectionTemplateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="RowsPerPageSelectionTemplate"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty RowsPerPageSelectionTemplateProperty
            = DependencyProperty.Register(nameof(RowsPerPageSelectionTemplate), typeof(DataTemplate), typeof(PagedDataGrid), new FrameworkPropertyMetadata(null));

        /// <summary>
        /// Gets or sets a value indicating how many rows shall are displayed per page.
        /// Set to 0 or negative value and paging won't be functional.
        /// </summary>
        public int RowsPerPage
        {
            get => (int)GetValue(RowsPerPageProperty);
            set => SetCurrentValue(RowsPerPageProperty, value);
        }
        /// <summary>
        /// Registers <see cref="RowsPerPage"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty RowsPerPageProperty
            = DependencyProperty.Register(nameof(RowsPerPage), typeof(int), typeof(PagedDataGrid), new FrameworkPropertyMetadata(0, RowsPerPageChanged));

        /// <summary>
        /// Called whenever the <see cref="RowsPerPage"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void RowsPerPageChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted) || !(args.NewValue is int newValue))
                return;
            
            casted.CancelEditWithCare();
            casted._pagedTable.RecordsPerPage = newValue;
        }
        #endregion

        #region Current page
        /// <summary>
        /// Gets the current page number of a paged DataGrid.
        /// </summary>
        public uint CurrentPageIndex
        {
            get => (uint)GetValue(CurrentPageIndexProperty);
            protected set => SetValue(_currentPageIndexPropertyKey, value);
        }
        private static readonly DependencyPropertyKey _currentPageIndexPropertyKey =
            DependencyProperty.RegisterReadOnly(nameof(CurrentPageIndex), typeof(uint), typeof(PagedDataGrid), new PropertyMetadata(default(uint)));
        /// <summary>
        /// Registers <see cref="CurrentPageIndex"/> as a readonly dependency property.
        /// </summary>
        public static readonly DependencyProperty CurrentPageIndexProperty = _currentPageIndexPropertyKey.DependencyProperty;

        /// <summary>
        /// Gets the row selection option visibility.
        /// </summary>
        public string CurrentVisibleItemRangeText
        {
            get => (string)GetValue(CurrentVisibleItemRangeTextProperty);
            protected set => SetValue(_currentVisibleItemRangeTextPropertyKey, value);
        }
        private static readonly DependencyPropertyKey _currentVisibleItemRangeTextPropertyKey =
            DependencyProperty.RegisterReadOnly(nameof(CurrentVisibleItemRangeText), typeof(string), typeof(PagedDataGrid), new PropertyMetadata(default(string)));
        /// <summary>
        /// Registers <see cref="CurrentVisibleItemRangeText"/> as a readonly dependency property.
        /// </summary>
        public static readonly DependencyProperty CurrentVisibleItemRangeTextProperty = _currentVisibleItemRangeTextPropertyKey.DependencyProperty;

        /// <summary>
        /// Gets the text to be displayed between current page count and total page count.
        /// </summary>
        public string PageCountsSeparatorText
        {
            get => (string)GetValue(PageCountsSeparatorTextProperty);
            set => SetValue(PageCountsSeparatorTextProperty, value);
        }
        /// <summary>
        /// Registers <see cref="PageCountsSeparatorText"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty PageCountsSeparatorTextProperty =
            DependencyProperty.Register(nameof(PageCountsSeparatorText), typeof(string), typeof(PagedDataGrid), new FrameworkPropertyMetadata(" of ", PageCountsSeparatorTextChanged));

        /// <summary>
        /// Called whenever the <see cref="PageCountsSeparatorText"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void PageCountsSeparatorTextChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (sender is PagedDataGrid casted && args.NewValue is string)
                casted.UpdateCurrentVisibleItemRangeText();
        }

        /// <summary>
        /// Updates the current page item count text.
        /// </summary>
        private void UpdateCurrentVisibleItemRangeText()
        {
            CurrentVisibleItemRangeText = 
                _pagedTable.SourceItemsCount >= 0 ? (_pagedTable.CurrentPageRange.Item1 + "-" + _pagedTable.CurrentPageRange.Item2 + " " + PageCountsSeparatorText + " " + _pagedTable.SourceItemsCount) : string.Empty;
        }
        #endregion

        #region Sorting properties
        /// <summary>
        /// Gets or sets the index of the column that is or to be sorted.
        /// </summary>
        /// <remarks>Set a negative value to disable sorting on the DataGrid.</remarks>
        public int SortedColumnIndex
        {
            get => (int)GetValue(SortedColumnIndexProperty);
            set => SetCurrentValue(SortedColumnIndexProperty, value);
        }
        /// <summary>
        /// Registers <see cref="SortedColumnIndex"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty SortedColumnIndexProperty
            = DependencyProperty.Register(nameof(SortedColumnIndex), typeof(int), typeof(PagedDataGrid), new FrameworkPropertyMetadata(-1, SortedColumnIndexChanged));

        /// <summary>
        /// Called whenever the <see cref="SortedColumnIndex"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void SortedColumnIndexChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted) || !(args.NewValue is int newValue))
                return;
            
            casted.UnsetSortingOnPreviousSortedColumn();

            if (casted._sortingInnerChange)
                return;
            
            if (casted.IsLoaded)
                casted._pagedTable.SortItems(newValue, !casted.IsSortingDescending, casted.GetCurrentSortMemberPath());
            else casted._sortedColumnIndexInit = newValue;
        }
        
        /// <summary>
        /// Checks if sorting column changed and disables
        /// sorting on previous sorted one.
        /// </summary>
        private void UnsetSortingOnPreviousSortedColumn()
        {
            if (_pagedTable.SortingColumnIndex >= 0
                && _pagedTable.SortingColumnIndex != SortedColumnIndex
                && _pagedTable.SortingColumnIndex < Columns.Count)
                Columns[_pagedTable.SortingColumnIndex].SortDirection = null;
        }

        /// <summary>
        /// Gets or sets a value indicating is sorting is set 
        /// on descending order on the sorted column.
        /// </summary>
        public bool IsSortingDescending
        {
            get => (bool)GetValue(IsSortingDescendingProperty);
            set => SetCurrentValue(IsSortingDescendingProperty, value);
        }
        /// <summary>
        /// Registers <see cref="IsSortingDescending"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty IsSortingDescendingProperty
            = DependencyProperty.Register(nameof(IsSortingDescending), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(bool), IsSortingDescendingChanged));

        /// <summary>
        /// Called whenever the <see cref="IsSortingDescending"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void IsSortingDescendingChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted))
                return;
            
            if (!casted._sortingInnerChange)
                casted._pagedTable.SortItems(casted.SortedColumnIndex, (args.NewValue as bool?) == true, casted.GetCurrentSortMemberPath());
        }

        /// <summary>
        /// Gets or sets a value indicating is sorting should be reapplied
        /// everytime the source size updates or a value changed in the currently
        /// sorted column (if any).
        /// </summary>
        /// <remarks>Seems equivalent to IsLiveSorting on certain collections.</remarks>
        public bool IsSortingPersistent
        {
            get => (bool)GetValue(IsSortingPersistentProperty);
            set => SetCurrentValue(IsSortingPersistentProperty, value);
        }
        /// <summary>
        /// Registers <see cref="IsSortingPersistent"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty IsSortingPersistentProperty
            = DependencyProperty.Register(nameof(IsSortingPersistent), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(bool), IsSortingPersistentChanged));

        /// <summary>
        /// Called whenever the <see cref="IsSortingPersistent"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void IsSortingPersistentChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (sender is PagedDataGrid casted && args.NewValue is bool newValue)
                casted._pagedTable.IsSortingPersistent = newValue;
        }

        /// <summary>
        /// Gets or sets a path to a property to use on source item for sorting.
        /// Common to all columns, meaning source objects must display this property (or give access to),
        /// but this is not mandatory, as if not displayable on source object, its self value will be used. 
        /// </summary>
        public string CommonSortedMemberPath
        {
            get => (string)GetValue(CommonSortedMemberPathProperty);
            set => SetCurrentValue(CommonSortedMemberPathProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CommonSortedMemberPath"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CommonSortedMemberPathProperty  // init with fake non-null.
            = DependencyProperty.Register(nameof(CommonSortedMemberPath), typeof(string), typeof(PagedDataGrid), new FrameworkPropertyMetadata("1", CommonSortedMemberPathChanged));   

        /// <summary>
        /// Called whenever the <see cref="CommonSortedMemberPath"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void CommonSortedMemberPathChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted))
                return;
            
            if (casted._pagedTable.IsSorting)
                casted._pagedTable.UpdateCurrentPage();
        }
        #endregion

        #region Additional content properties
        /// <summary>
        /// Gets or sets a value indicating if more options can be used for the control.
        /// </summary>
        public bool CanShowAdditionalOptions
        {
            get => (bool)GetValue(CanShowAdditionalOptionsProperty);
            set => SetCurrentValue(CanShowAdditionalOptionsProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CanShowAdditionalOptions"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CanShowAdditionalOptionsProperty
            = DependencyProperty.Register(nameof(CanShowAdditionalOptions), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(bool), CanShowAdditionalOptionsChanged));

        /// <summary>
        /// Called whenever the <see cref="CanShowAdditionalOptions"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void CanShowAdditionalOptionsChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (sender is PagedDataGrid casted && args.NewValue is bool)
                casted.AdditionalOptionsVisibility = args.NewValue as bool? == true ? Visibility.Visible : Visibility.Collapsed;
        }

        /// <summary>
        /// Gets the visibility of the additional options.
        /// </summary>
        public Visibility AdditionalOptionsVisibility
        {
            get => (Visibility)GetValue(AdditionalOptionsVisibilityProperty);
            protected set => SetValue(_additionalOptionsVisibilityPropertyKey, value);
        }
        private static readonly DependencyPropertyKey _additionalOptionsVisibilityPropertyKey =
            DependencyProperty.RegisterReadOnly(nameof(AdditionalOptionsVisibility), typeof(Visibility), typeof(PagedDataGrid), new PropertyMetadata(Visibility.Collapsed));
        /// <summary>
        /// Registers <see cref="AdditionalOptionsVisibility"/> as a readonly dependency property.
        /// </summary>
        public static readonly DependencyProperty AdditionalOptionsVisibilityProperty = _additionalOptionsVisibilityPropertyKey.DependencyProperty;

        /// <summary>
        /// Gets or sets the template to be used for additional options.
        /// </summary>
        public DataTemplate AdditionalOptionsTemplate
        {
            get => (DataTemplate)GetValue(AdditionalOptionsTemplateProperty);
            set => SetCurrentValue(AdditionalOptionsTemplateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="AdditionalOptionsTemplate"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty AdditionalOptionsTemplateProperty
            = DependencyProperty.Register(nameof(AdditionalOptionsTemplate), typeof(DataTemplate), typeof(PagedDataGrid), new FrameworkPropertyMetadata(null));
        #endregion

        #region Checkmarks and ID columns settings
        /// <summary>
        /// Gets or sets a value indicating if user can reorder index and selector.
        /// </summary>
        /// <remarks>No effect while CanUserReorderColumns is false.</remarks>
        public bool CanUserReorderIDsAndCheckMarksColumns
        {
            get => (bool)GetValue(CanUserReorderIDsAndCheckMarksColumnsProperty);
            set => SetCurrentValue(CanUserReorderIDsAndCheckMarksColumnsProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CanUserReorderIDsAndCheckMarksColumns"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CanUserReorderIDsAndCheckMarksColumnsProperty
            = DependencyProperty.Register(nameof(CanUserReorderIDsAndCheckMarksColumns), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(bool), CanUserReorderIDsAndCheckMarksColumnsChanged));

        /// <summary>
        /// Called whenever the <see cref="CanUserReorderIDsAndCheckMarksColumns"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void CanUserReorderIDsAndCheckMarksColumnsChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted))
                return;
            
            casted.CancelEditWithCare();
            casted._pagedTable.UpdateCurrentPage();  // force update to force column auto-generation
        }

        #region CheckMarks processing part
        /// <summary>
        /// Gets source items that are check marked with selector column.
        /// </summary>
        public IEnumerable<object> CheckMarkedItems
        {
            get => (IEnumerable<object>)GetValue(CheckMarkedItemsProperty);
            set => SetCurrentValue(CheckMarkedItemsProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CheckMarkedItems"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CheckMarkedItemsProperty =
            DependencyProperty.Register(nameof(CheckMarkedItems), typeof(IEnumerable<object>), typeof(PagedDataGrid), new PropertyMetadata(null, CheckMarkedItemsChanged));

        /// <summary>
        /// Called whenever the <see cref="CheckMarkedItems"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void CheckMarkedItemsChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted))
                return;
            
            if (!Equals(args.NewValue, casted._pagedTable.CheckMarkedRows))
            {
                throw new NotSupportedException(nameof(CheckMarkedItems) + " property of " + nameof(PagedDataGrid) +
                                                " is not set as read-only for convenience but must be treated as it is. Set binding mode to OneWayToSource or avoid changing this property value.");
            }
        }

        /// <summary>
        /// Gets or sets a value indicating the selection state of rows.
        /// </summary>
        public bool? SelectAllRowsState
        {
            get => (bool?)GetValue(SelectAllRowsStateProperty);
            set => SetCurrentValue(SelectAllRowsStateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="ShowsCheckMarks"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty SelectAllRowsStateProperty
            = DependencyProperty.Register(nameof(SelectAllRowsState), typeof(bool?), typeof(PagedDataGrid), new FrameworkPropertyMetadata(true, SelectAllRowsStateChanged));

        /// <summary>
        /// Called whenever the <see cref="SelectAllRowsState"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void SelectAllRowsStateChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted) || !(args.NewValue is bool newValue))
                return;
            
            casted.CancelEditWithCare();
            if (newValue)
                casted._pagedTable.CheckMarkAllRows();
            else
                casted._pagedTable.UncheckMarkAllRows();
        }

        /// <summary>
        /// Gets the list of indexes currently displayed on the grid.
        /// </summary>
        public bool SelectAllRowsIsTriStated
        {
            get => (bool)GetValue(SelectAllRowsIsTriStatedProperty);
            protected set => SetValue(_selectAllRowsIsTriStatedPropertyKey, value);
        }
        private static readonly DependencyPropertyKey _selectAllRowsIsTriStatedPropertyKey =
            DependencyProperty.RegisterReadOnly(nameof(SelectAllRowsIsTriStated), typeof(bool), typeof(PagedDataGrid), new PropertyMetadata(default(bool)));
        /// <summary>
        /// Registers <see cref="SelectAllRowsIsTriStated"/> as a readonly dependency property.
        /// </summary>
        public static readonly DependencyProperty SelectAllRowsIsTriStatedProperty = _selectAllRowsIsTriStatedPropertyKey.DependencyProperty;
        #endregion

        #region CheckMarks part
        /// <summary>
        /// Gets or sets a value indicating if the row selection column must be displayed.
        /// </summary>
        public bool ShowsCheckMarks
        {
            get => (bool)GetValue(ShowsCheckMarksProperty);
            set => SetCurrentValue(ShowsCheckMarksProperty, value);
        }
        /// <summary>
        /// Registers <see cref="ShowsCheckMarks"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty ShowsCheckMarksProperty
            = DependencyProperty.Register(nameof(ShowsCheckMarks), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(bool), ShowsCheckMarksChanged));

        /// <summary>
        /// Called whenever the <see cref="ShowsCheckMarks"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void ShowsCheckMarksChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted) || !(args.NewValue is bool newValue))
                return;
            
            casted.CancelEditWithCare();
            casted._pagedTable.HasCheckmarks = newValue;

            // In case this property disabled paging,
            // then force source update to original list:
            if (newValue || casted.UsesPagingInternal)
                return;
            
            try
            {
                casted._columnsInnerChange = true;
                casted.InvalidateProperty(ItemsSourceProperty);
            }
            finally
            {
                casted._columnsInnerChange = false;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating if the row selection column must be displayed.
        /// </summary>
        public IList<bool> CheckMarksValues
        {
            get => (IList<bool>)GetValue(CheckMarksValuesProperty);
            set => SetCurrentValue(CheckMarksValuesProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CheckMarksValues"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CheckMarksValuesProperty
            = DependencyProperty.Register(nameof(CheckMarksValues), typeof(IList<bool>), typeof(PagedDataGrid), 
                new FrameworkPropertyMetadata(default(IList<bool>), FrameworkPropertyMetadataOptions.BindsTwoWayByDefault, CheckMarksValuesChanged));

        /// <summary>
        /// Called whenever the <see cref="CheckMarksValues"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void CheckMarksValuesChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted) || !(args.NewValue is IList<bool> newValue))
                return;
            
            if (!casted.IsLoaded)
                casted._checkMarksValuesBackup = new List<bool>(newValue);  // keep a backup to restore at loading.
            else if (!casted._checkmarksInnerChange)
            {
                casted.CancelEditWithCare();
                casted._pagedTable.SetRowCheckMarksValues(newValue);  // else set selector values normally.
            }
        }

        /// <summary>
        /// Gets or sets the column index of the selectors column.
        /// </summary>
        public int CheckMarksColumnIndex
        {
            get => (int)GetValue(CheckMarksColumnIndexProperty);
            set => SetCurrentValue(CheckMarksColumnIndexProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CheckMarksColumnIndex"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CheckMarksColumnIndexProperty
            = DependencyProperty.Register(nameof(CheckMarksColumnIndex), typeof(int), typeof(PagedDataGrid), new FrameworkPropertyMetadata(0, CheckMarksColumnIndexChanged));

        /// <summary>
        /// Called whenever the <see cref="CheckMarksColumnIndex"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void CheckMarksColumnIndexChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted) || !(args.NewValue is int newValue))
                return;
            
            casted.CancelEditWithCare();
            casted._pagedTable.CheckMarksColumnPosition = newValue;
        }

        /// <summary>
        /// Gets or sets the style of the selector column header.
        /// </summary>
        public Style CheckMarksColumnHeaderStyle
        {
            get => (Style)GetValue(CheckMarksColumnHeaderStyleProperty);
            set => SetCurrentValue(CheckMarksColumnHeaderStyleProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CheckMarksColumnHeaderStyle"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CheckMarksColumnHeaderStyleProperty
            = DependencyProperty.Register(nameof(CheckMarksColumnHeaderStyle), typeof(Style), typeof(PagedDataGrid), new FrameworkPropertyMetadata(null));

        /// <summary>
        /// Gets or sets the template for the selector column header.
        /// </summary>
        public DataTemplate CheckMarksColumnHeaderTemplate
        {
            get => (DataTemplate)GetValue(CheckMarksColumnHeaderTemplateProperty);
            set => SetCurrentValue(CheckMarksColumnHeaderTemplateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CheckMarksColumnHeaderTemplate"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CheckMarksColumnHeaderTemplateProperty
            = DependencyProperty.Register(nameof(CheckMarksColumnHeaderTemplate), typeof(DataTemplate), typeof(PagedDataGrid), new FrameworkPropertyMetadata(null));

        /// <summary>
        /// Gets or sets a template selector for the selector column header.
        /// </summary>
        public DataTemplateSelector CheckMarksColumnHeaderTemplateSelector
        {
            get => (DataTemplateSelector)GetValue(CheckMarksColumnHeaderTemplateSelectorProperty);
            set => SetCurrentValue(CheckMarksColumnHeaderTemplateSelectorProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CheckMarksColumnHeaderTemplateSelector"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CheckMarksColumnHeaderTemplateSelectorProperty
            = DependencyProperty.Register(nameof(CheckMarksColumnHeaderTemplateSelector), typeof(DataTemplateSelector), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplateSelector)));

        /// <summary>
        /// Gets or sets the style of the selector cell.
        /// </summary>
        public Style CheckMarkCellStyle
        {
            get => (Style)GetValue(CheckMarkCellStyleProperty);
            set => SetCurrentValue(CheckMarkCellStyleProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CheckMarkCellStyle"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CheckMarkCellStyleProperty
            = DependencyProperty.Register(nameof(CheckMarkCellStyle), typeof(Style), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(Style)));

        /// <summary>
        /// Gets or sets a specific template for selector cells.
        /// </summary>
        public DataTemplate CheckMarkCellTemplate
        {
            get => (DataTemplate)GetValue(CheckMarkCellTemplateProperty);
            set => SetCurrentValue(CheckMarkCellTemplateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CheckMarkCellTemplate"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CheckMarkCellTemplateProperty
            = DependencyProperty.Register(nameof(CheckMarkCellTemplate), typeof(DataTemplate), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplate)));

        /// <summary>
        /// Gets or sets a template selector for selector cells.
        /// </summary>
        public DataTemplateSelector CheckMarkCellTemplateSelector
        {
            get => (DataTemplateSelector)GetValue(CheckMarkCellTemplateSelectorProperty);
            set => SetCurrentValue(CheckMarkCellTemplateSelectorProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CheckMarkCellTemplateSelector"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CheckMarkCellTemplateSelectorProperty
            = DependencyProperty.Register(nameof(CheckMarkCellTemplateSelector), typeof(DataTemplateSelector), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplateSelector)));

        /// <summary>
        /// Gets or sets a template to be applied when selector cells are being edited.
        /// </summary>
        public DataTemplate CheckMarkCellEditingTemplate
        {
            get => (DataTemplate)GetValue(CheckMarkCellEditingTemplateProperty);
            set => SetCurrentValue(CheckMarkCellEditingTemplateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CheckMarkCellEditingTemplate"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CheckMarkCellEditingTemplateProperty
            = DependencyProperty.Register(nameof(CheckMarkCellEditingTemplate), typeof(DataTemplate), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplate)));

        /// <summary>
        /// Gets or sets a template selector for selector cells in edit mode.
        /// </summary>
        public DataTemplateSelector CheckMarkCellEditingTemplateSelector
        {
            get => (DataTemplateSelector)GetValue(CheckMarkCellEditingTemplateSelectorProperty);
            set => SetCurrentValue(CheckMarkCellEditingTemplateSelectorProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CheckMarkCellEditingTemplateSelector"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CheckMarkCellEditingTemplateSelectorProperty
            = DependencyProperty.Register(nameof(CheckMarkCellEditingTemplateSelector), typeof(DataTemplateSelector), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplateSelector)));
        #endregion

        #region ID part
        /// <summary>
        /// Gets or sets a value indicating if a column showing indexes must be shown.
        /// </summary>
        public bool ShowsIDs
        {
            get => (bool)GetValue(ShowsIDsProperty);
            set => SetCurrentValue(ShowsIDsProperty, value);
        }
        /// <summary>
        /// Registers <see cref="ShowsIDs"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty ShowsIDsProperty
            = DependencyProperty.Register(nameof(ShowsIDs), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(bool), ShowsIDsChanged));

        /// <summary>
        /// Called whenever the <see cref="ShowsIDs"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void ShowsIDsChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (!(sender is PagedDataGrid casted) || !(args.NewValue is bool newValue))
                return;
            
            casted.CancelEditWithCare();
            casted._pagedTable.HasIndexes = newValue;

            // In case this property disabled paging,
            // then force source update to original list:
            if (newValue || casted.UsesPagingInternal)
                return;
            
            try
            {
                casted._columnsInnerChange = true;
                casted.InvalidateProperty(ItemsSourceProperty);
            }
            finally
            {
                casted._columnsInnerChange = false;
            }
        }

        /// <summary>
        /// Gets the list of indexes currently displayed on the grid.
        /// </summary>
        public ReadOnlyCollection<int> DisplayedIDs
        {
            get => (ReadOnlyCollection<int>)GetValue(DisplayedIDsProperty);
            protected set => SetValue(_displayedIDsPropertyKey, value);
        }
        private static readonly DependencyPropertyKey _displayedIDsPropertyKey =
            DependencyProperty.RegisterReadOnly(nameof(DisplayedIDs), typeof(ReadOnlyCollection<int>), typeof(PagedDataGrid), new PropertyMetadata(default(ReadOnlyCollection<int>)));
        /// <summary>
        /// Registers <see cref="DisplayedIDs"/> as a readonly dependency property.
        /// </summary>
        public static readonly DependencyProperty DisplayedIDsProperty = _displayedIDsPropertyKey.DependencyProperty;

        /// <summary>
        /// Gets or sets a value indicating if ID numbers 
        /// should start from 0 instead of 1.
        /// </summary>
        public bool IdsStartFromZero
        {
            get => (bool)GetValue(IdsStartFromZeroProperty);
            set => SetCurrentValue(IdsStartFromZeroProperty, value);
        }
        /// <summary>
        /// Registers <see cref="IdsStartFromZero"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty IdsStartFromZeroProperty
            = DependencyProperty.Register(nameof(IdsStartFromZero), typeof(bool), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(bool), IdsStartFromZeroChanged));

        /// <summary>
        /// Called whenever the <see cref="IdsStartFromZero"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void IdsStartFromZeroChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (sender is PagedDataGrid casted)
                casted._pagedTable.IndexesStartAtZero = args.NewValue as bool? == true;
        }

        /// <summary>
        /// Gets or sets the column index of the IDs column.
        /// </summary>
        public int IdsColumnIndex
        {
            get => (int)GetValue(IdsColumnIndexProperty);
            set => SetCurrentValue(IdsColumnIndexProperty, value);
        }
        /// <summary>
        /// Registers <see cref="IdsColumnIndex"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty IdsColumnIndexProperty
            = DependencyProperty.Register(nameof(IdsColumnIndex), typeof(int), typeof(PagedDataGrid), new FrameworkPropertyMetadata(1, IdsColumnIndexChanged));

        /// <summary>
        /// Called whenever the <see cref="IdsColumnIndex"/> property changes.
        /// </summary>
        /// <param name="sender">The object whose property changed.</param>
        /// <param name="args">Information about the property change.</param>
        private static void IdsColumnIndexChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args)
        {
            if (sender is PagedDataGrid casted && args.NewValue is int newValue)
                casted._pagedTable.IndexesColumnPosition = newValue;
        }

        /// <summary>
        /// Gets or sets the style of the index column header.
        /// </summary>
        public Style IdsColumnHeaderStyle
        {
            get => (Style)GetValue(IdsColumnHeaderStyleProperty);
            set => SetCurrentValue(IdsColumnHeaderStyleProperty, value);
        }
        /// <summary>
        /// Registers <see cref="IdsColumnHeaderStyle"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty IdsColumnHeaderStyleProperty
            = DependencyProperty.Register(nameof(IdsColumnHeaderStyle), typeof(Style), typeof(PagedDataGrid), new FrameworkPropertyMetadata(null));

        /// <summary>
        /// Gets or sets the template for the index column header.
        /// </summary>
        public DataTemplate IdsColumnHeaderTemplate
        {
            get => (DataTemplate)GetValue(IdsColumnHeaderTemplateProperty);
            set => SetCurrentValue(IdsColumnHeaderTemplateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="IdsColumnHeaderTemplate"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty IdsColumnHeaderTemplateProperty
            = DependencyProperty.Register(nameof(IdsColumnHeaderTemplate), typeof(DataTemplate), typeof(PagedDataGrid), new FrameworkPropertyMetadata(null));

        /// <summary>
        /// Gets or sets a template selector for the index column header.
        /// </summary>
        public DataTemplateSelector IdsColumnHeaderTemplateSelector
        {
            get => (DataTemplateSelector)GetValue(IdsColumnHeaderTemplateSelectorProperty);
            set => SetCurrentValue(IdsColumnHeaderTemplateSelectorProperty, value);
        }
        /// <summary>
        /// Registers <see cref="IdsColumnHeaderTemplateSelector"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty IdsColumnHeaderTemplateSelectorProperty
            = DependencyProperty.Register(nameof(IdsColumnHeaderTemplateSelector), typeof(DataTemplateSelector), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplateSelector)));

        /// <summary>
        /// Gets or sets the style of the ID cell.
        /// </summary>
        public Style IdCellStyle
        {
            get => (Style)GetValue(IdCellStyleProperty);
            set => SetCurrentValue(IdCellStyleProperty, value);
        }
        /// <summary>
        /// Registers <see cref="IdCellStyle"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty IdCellStyleProperty
            = DependencyProperty.Register(nameof(IdCellStyle), typeof(Style), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(Style)));

        /// <summary>
        /// Gets or sets a specific template for ID cells.
        /// </summary>
        public DataTemplate IdCellTemplate
        {
            get => (DataTemplate)GetValue(IdCellTemplateProperty);
            set => SetCurrentValue(IdCellTemplateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="IdCellTemplate"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty IdCellTemplateProperty
            = DependencyProperty.Register(nameof(IdCellTemplate), typeof(DataTemplate), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplate)));

        /// <summary>
        /// Gets or sets a template selector for ID cells.
        /// </summary>
        public DataTemplateSelector IdCellTemplateSelector
        {
            get => (DataTemplateSelector)GetValue(IdCellTemplateSelectorProperty);
            set => SetCurrentValue(IdCellTemplateSelectorProperty, value);
        }
        /// <summary>
        /// Registers <see cref="IdCellTemplateSelector"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty IdCellTemplateSelectorProperty
            = DependencyProperty.Register(nameof(IdCellTemplateSelector), typeof(DataTemplateSelector), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplateSelector)));
        #endregion

        #endregion

        #region 'Normal' cells part
        /// <summary>
        /// Gets or sets a uniform template for cells.
        /// </summary>
        public DataTemplate CellTemplate
        {
            get => (DataTemplate)GetValue(CellTemplateProperty);
            set => SetCurrentValue(CellTemplateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CellTemplate"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CellTemplateProperty
            = DependencyProperty.Register(nameof(CellTemplate), typeof(DataTemplate), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplate)));

        /// <summary>
        /// Gets or sets a template selector for cells.
        /// </summary>
        public DataTemplateSelector CellTemplateSelector
        {
            get => (DataTemplateSelector)GetValue(CellTemplateSelectorProperty);
            set => SetCurrentValue(CellTemplateSelectorProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CellTemplateSelector"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CellTemplateSelectorProperty
            = DependencyProperty.Register(nameof(CellTemplateSelector), typeof(DataTemplateSelector), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplateSelector)));

        /// <summary>
        /// Gets or sets a uniform template to be applied when cells are being edited.
        /// </summary>
        public DataTemplate CellEditingTemplate
        {
            get => (DataTemplate)GetValue(CellEditingTemplateProperty);
            set => SetCurrentValue(CellEditingTemplateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CellEditingTemplate"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CellEditingTemplateProperty
            = DependencyProperty.Register(nameof(CellEditingTemplate), typeof(DataTemplate), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplate)));

        /// <summary>
        /// Gets or sets a template selector for cells in edit mode.
        /// </summary>
        public DataTemplateSelector CellEditingTemplateSelector
        {
            get => (DataTemplateSelector)GetValue(CellEditingTemplateSelectorProperty);
            set => SetCurrentValue(CellEditingTemplateSelectorProperty, value);
        }
        /// <summary>
        /// Registers <see cref="CellEditingTemplateSelector"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty CellEditingTemplateSelectorProperty
            = DependencyProperty.Register(nameof(CellEditingTemplateSelector), typeof(DataTemplateSelector), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplateSelector)));

        /// <summary>
        /// Gets or sets a template for column headers.
        /// </summary>
        public DataTemplate ColumnHeaderTemplate
        {
            get => (DataTemplate)GetValue(ColumnHeaderTemplateProperty);
            set => SetCurrentValue(ColumnHeaderTemplateProperty, value);
        }
        /// <summary>
        /// Registers <see cref="ColumnHeaderTemplate"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty ColumnHeaderTemplateProperty
            = DependencyProperty.Register(nameof(ColumnHeaderTemplate), typeof(DataTemplate), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplate)));

        /// <summary>
        /// Gets or sets a template selector for column headers.
        /// </summary>
        public DataTemplateSelector ColumnHeaderTemplateSelector
        {
            get => (DataTemplateSelector)GetValue(ColumnHeaderTemplateSelectorProperty);
            set => SetCurrentValue(ColumnHeaderTemplateSelectorProperty, value);
        }
        /// <summary>
        /// Registers <see cref="ColumnHeaderTemplateSelector"/> as a dependency property.
        /// </summary>
        public static readonly DependencyProperty ColumnHeaderTemplateSelectorProperty
            = DependencyProperty.Register(nameof(ColumnHeaderTemplateSelector), typeof(DataTemplateSelector), typeof(PagedDataGrid), new FrameworkPropertyMetadata(default(DataTemplateSelector)));
        #endregion

        #region Add/delete items, column reordering and item sorting
        /// <summary>
        /// Called whenever the DataGrid attempts to create a new item. Tries to update source accordingly.
        /// </summary>
        /// <param name="e">Item creation event information.</param>
        protected override void OnInitializingNewItem(InitializingNewItemEventArgs e)
        {
            // If we use the internal paging system:
            if (UsesPagingInternal && e.NewItem is DataRowView)
            {
                CommitEdit();  // commit any edit in progress before we go.

                // Get current cell position:
                var itemAddedColumnIndex = Columns.IndexOf(CurrentCell.Column);  // keep in mind.
                var pageWasFull = _pagedTable.CurrentPageIsFull;

                // Call later (after all 'add item' process is over):
                Dispatcher.BeginInvoke(System.Windows.Threading.DispatcherPriority.Render, new Action(() =>
                {
                    if (Columns.Count > itemAddedColumnIndex && Items.Count > 1)
                    {
                        if (_pagedTable.AddRow() && itemAddedColumnIndex >= 0)
                        {
                            if (pageWasFull)
                                _pagedTable.GoLast();                         
                            else _pagedTable.UpdateCurrentPage();

                            // Reproduce the behavior of the base DataGrid here by putting last line into edit mode:
                            var itemsCount = Items.Count;
                            if (itemsCount > 1 && itemAddedColumnIndex < Columns.Count)
                            {
                                CurrentCell = new DataGridCellInfo(Items[Items.Count - 2], Columns[itemAddedColumnIndex]);
                                BeginEdit();
                            }
                        }
                    }
                }));
            }

            // Let base class do/finish the job:
            base.OnInitializingNewItem(e);
        }

        /// <summary>
        /// Called whenever a change is validated in a cell.
        /// </summary>
        /// <param name="e">Information about value change.</param>
        protected override void OnExecutedCommitEdit(ExecutedRoutedEventArgs e)
        {
            // De-synchronization with base list can occur and trigger an exception here
            // Normally every cases were checked and CancelEdit() placed everywhere there might be an edition,
            // but we let the try/catch here in case we missed one:
            try
            {
                base.OnExecutedCommitEdit(e);
            }
            catch (Exception except) //TODO: since bug is persistent even after page changes, find a way to reset DataGrid.
            {
                if (!(except is ArgumentNullException nullException) || nullException.ParamName != "element")  // very specific error appearing for de-synchronization.
                    throw;
            }
        }

        /// <summary>
        /// Cancels edition while handling any source de-synchronization that might occur.
        /// </summary>
        private void CancelEditWithCare()
        {
            try
            {
                CancelEdit();
            }
            catch (Exception except)
            {
                if (!(except is ArgumentNullException nullException) || nullException.ParamName != "element")  // very specific error appearing for de-synchronization.
                    throw;
            }
        }

        /// <summary>
        /// Called whenever an item is deleted from the DataGrid. Updates source accordingly.
        /// </summary>
        /// <param name="e">Delete event information.</param>
        protected override void OnExecutedDelete(ExecutedRoutedEventArgs e)
        {
            // Ask table to delete this row if possible when using it as source:
            if (UsesPagingInternal && SelectedItems.Count > 0 && SelectedItems[0] is DataRowView)
            {
                foreach (var selected in SelectedItems)
                    _pagedTable.DeleteRow(selected as DataRowView);
                _pagedTable.UpdateCurrentPage();
            }
            // or let base class do the job when normal item source is used:
            else base.OnExecutedDelete(e);
        }

        /// <summary>
        /// Processes column reordering, especially for index and selector columns 
        /// when allowed to do so.
        /// </summary>
        /// <param name="e">Event info.</param>
        protected override void OnColumnReordered(DataGridColumnEventArgs e)
        {
            if (ShowsCheckMarks || ShowsIDs)
            {
                var movedIndex = e.Column.DisplayIndex;
                var isSelect = ShowsCheckMarks && movedIndex == CheckMarksColumnIndex;
                var isId = ShowsIDs && movedIndex == IdsColumnIndex;
                if ((isSelect || isId) && CanUserReorderColumns && CanUserReorderIDsAndCheckMarksColumns)
                {
                    if (isSelect)
                        _pagedTable.IndexesColumnPosition = movedIndex;
                    else
                        _pagedTable.CheckMarksColumnPosition = movedIndex;
                }
                else if (!CanUserReorderColumns || !CanUserReorderIDsAndCheckMarksColumns)
                {
                    if (movedIndex <= CheckMarksColumnIndex || movedIndex <= IdsColumnIndex)
                        _pagedTable.UpdateCurrentPage();  // forces update in case something not authorized happened.
                }
            }
            base.OnColumnReordered(e);
        }

        /// <summary>
        /// Occurs whenever a column is being sorted.
        /// </summary>
        /// <param name="eventArgs">Event information.</param>
        protected override void OnSorting(DataGridSortingEventArgs eventArgs)
        {
            var columnIndex = Columns.IndexOf(eventArgs.Column);
            if (UsesPagingInternal && columnIndex >= 0)
            {
                var ascendingNotDescending = IsSortingDescending;  // toggle here

                // If sorting a new column then sort ascending:
                if (SortedColumnIndex != columnIndex)
                {
                    ascendingNotDescending = true;
                    _sortingInnerChange = true;
                    SortedColumnIndex = columnIndex;
                    IsSortingDescending = false;
                    _sortingInnerChange = false;
                    _pagedTable.SortItems(columnIndex, true, GetCurrentSortMemberPath());

                    // Reset previous column sorted state if existing:
                    if (SortedColumnIndex >= 0 && SortedColumnIndex < Columns.Count)
                        Columns[SortedColumnIndex].SortDirection = null;
                }
                else // else toggle ascending/descending orders:
                {
                    _sortingInnerChange = true;
                    IsSortingDescending = !ascendingNotDescending;
                    _sortingInnerChange = false;
                    _pagedTable.SortItems(columnIndex, ascendingNotDescending, GetCurrentSortMemberPath());
                }

                if (SortedColumnIndex >= 0)
                    Columns[SortedColumnIndex].SortDirection = ascendingNotDescending ? ListSortDirection.Ascending : ListSortDirection.Descending;
            }
            else base.OnSorting(eventArgs);
        }

        /// <summary>
        /// Returns the currently sorted column member path.
        /// </summary>
        /// <returns>A property name for sorting.</returns>
        private string GetCurrentSortMemberPath()
        {
            if (SortedColumnIndex < 0 || SortedColumnIndex >= Columns.Count)
                return null;
            
            var columnMemberPath = Columns[SortedColumnIndex].SortMemberPath;
            return columnMemberPath == _defaultSortMemberPath ? null : columnMemberPath;
        }
        #endregion
    }
}